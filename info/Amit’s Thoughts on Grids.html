
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Amit’s Thoughts on Grids</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/~amitp/favicon.ico"><link rel="apple-touch-icon" href="/~amitp/red_blob.gif"><link rel="preload" as="image" href="/~amitp/transparent-blob.png"><link rel="canonical" href="http://www-cs-students.stanford.edu/~amitp/game-programming/grids/"><link rel="alternate" type="application/atom+xml" title="Blobs in Games - Atom" href="https://simblob.blogspot.com/feeds/posts/default"><meta name="twitter:creator" content="@redblobgames"><meta name="theme-color" content="hsl(0,50%,45%)"><meta name="verify-v1" content="82b+h1+tgwLrcTqTiJrqquMvoFVBwMwY11dx63m01zk="><style>
              body{--hue: 0;--serif: Cambria,Georgia,serif;--sans-serif: system-ui,-apple-system,"Segoe UI","Helvetica Neue",sans-serif;--monospace: "Roboto Mono","Consolas",monospace,"Segoe UI Symbol","Symbol";--font-size: 16px;--font-size: calc(10px + 1vw);--line-height: 24px;--line-height: calc(1.5 * var(--font-size));--body-width: 660px;--body-width: calc(100vw - 36px);font-family:sans-serif;font-family:var(--sans-serif);font-size:16px;font-size:var(--font-size);line-height:1.5em;min-height:95%}@media (min-width: 550px){body{--body-width: calc(330px + 33vw);--font-size: calc(var(--body-width) / 33)}}@media (min-width: 1000px){body{--body-width: 660px}}main{font-family:var(--serif)}h1,h2,h3,h4,h5,h6,figcaption,.sans-serif{font-family:var(--sans-serif)}tt,code,kbd,samp,pre{font-family:monospace;font-family:var(--monospace);font-size:0.8em;font-size-adjust:none}#table-of-contents{background-color:#fff;margin-left:2em;padding-left:2em;width:20em;float:right}#table-of-contents:after{clear:both}nav,#table-of-contents{font-family:var(--sans-serif);font-size:calc(var(--font-size) / 1.25)}@media screen{header,section>h2{text-shadow:0px 2px 5px rgba(0,0,0,0.8);text-rendering:optimizeLegibility}}h1{font-size:2.0em;margin:0;line-height:36px;line-height:calc(1.5 * var(--line-height))}h1 .subheading{font-size:0.5em;letter-spacing:normal;line-height:24px;line-height:var(--line-height)}sup,sub{position:relative;vertical-align:baseline;font-size:0.75em;line-height:0;padding-left:2px}sup{top:-0.5em}sub{bottom:-0.25em}*{box-sizing:border-box}html,body{margin:0;padding:0}html{background-color:#e4e4e0;color:#000}body{background-color:#fff;color:#333}header{display:block;text-align:center}header>h1{padding-top:24px;padding-top:var(--line-height)}@media screen{.colored-background,header,footer,.divider,section>h2{color:#fff;background-color:#ac3939;background-color:hsl(var(--hue), 50%, 45%);background-image:url("/~amitp/transparent-blob.png"),url("/~amitp/transparent-blob.png");background-position:0 0, 16px 16px;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.colored-background a,header a,footer a,.divider a,section>h2 a{color:#f0dbdb;color:hsl(var(--hue), 40%, 90%)}}footer a,.divider a{text-decoration:underline}main{margin-left:0;margin-right:0;padding-left:0;padding-right:0}section{margin-top:24px;margin-bottom:24px;margin-top:var(--line-height);margin-bottom:var(--line-height)}section>*,.comments{width:660px;width:var(--body-width);max-width:100%}@media screen{.comments,.below-divider{background-color:#e4e4e0}}.comments{padding-bottom:20px;text-shadow:1px 1px 3px #fff;font-size:0.8em}section>h2{--h2-margin: 3em;--h2-padding: 0.5em;margin:24px auto;margin:var(--line-height) auto;padding:calc(var(--line-height) / 2 - 1px) 0;font-size:1.25em;width:740px;width:calc(2 * var(--h2-margin) + var(--body-width));max-width:100%}section>h2>span{display:inline-block;margin-left:var(--h2-margin)}section>h2 a.anchor{float:right;width:var(--h2-margin);padding-right:var(--h2-padding);text-align:center;color:#ac3939;color:hsl(var(--hue), 50%, 45%)}section>h2:hover a.anchor{color:#d6c2c2;color:hsl(var(--hue), 20%, 80%)}h3{--h2-margin: 3em;margin:24px auto;margin:var(--line-height) auto;font-size:1.125em}h3 a.anchor{float:right;width:var(--h2-margin);padding-right:0.5em;text-align:center;color:#d6c2c2;color:hsl(var(--hue), 20%, 80%)}@media (min-width: 550px){h3 a.anchor{margin-right:calc(0em - var(--h2-margin))}}h3:hover a.anchor{color:#933;color:hsl(var(--hue), 50%, 40%)}header nav{display:block}header nav ul{text-align:center;display:-ms-flexbox;display:flex;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-pack:center;justify-content:center;line-height:1.0;margin:0}header nav ul li{display:inline-block;width:10%;padding:2px 5px;text-align:center;-ms-flex:0 0 4em;flex:0 0 4em;-ms-flex-item-align:center;-ms-grid-row-align:center;align-self:center;white-space:nowrap}header nav ul li a{display:block;width:100%;font-weight:bold;text-decoration:none}header nav ul li:hover{background-color:rgba(0,0,0,0.5);font-weight:bold}header,.divider,section>h2{border-bottom:1px solid #000}.divider,section>h2{border-top:1px solid #000}.divider{min-height:48px;min-height:calc(2 * var(--line-height));text-align:center}.below-divider{padding-top:24px;padding-top:var(--line-height)}.below-divider>p:first-child{font-size:1.25em;text-align:center;margin-top:0}footer{--footer-padding-y: calc(var(--line-height) / 2);--footer-padding-x: var(--font-size);padding:12px 16px;padding:var(--footer-padding-y) var(--footer-padding-x);border-top:1px solid #000}footer>div>address{display:block}footer>div>*{text-align:center}@media (min-width: 50em){footer>div{margin:0 auto;display:-ms-flexbox;display:flex;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-pack:center;justify-content:center;max-width:calc(2 * var(--body-width));width:calc(100vw - 2 * var(--footer-padding-x))}footer>div>address{-ms-flex:0 1 20em;flex:0 1 20em;-ms-flex-item-align:center;-ms-grid-row-align:center;align-self:center;text-align:left}footer>div>div{-ms-flex:1 1 20em;flex:1 1 20em;-ms-flex-item-align:center;-ms-grid-row-align:center;align-self:center;text-align:right}footer>div>div>p,footer>div>div>div{margin-top:0}}h2:target{animation:target-attention 0.4s 1;font-size:2.0em}@keyframes target-attention{0%{transform:scale(1.1)}100%{transform:scale(1.1)}}div:target{border:1px dashed #888}kbd kbd{padding:1px 7px;margin:0px 1px 3px 1px;font-size:0.75em;white-space:nowrap;background-color:#ddd;color:#242;border:1px solid rgba(0,0,0,0.2);border-radius:3px;box-shadow:inset 0 0 1px 1px #fff,0 2px 0 rgba(0,0,0,0.3)}samp,kbd{background-color:#f3f3f2}code,samp{color:#442}kbd{margin:0 7px;color:#252}img{max-width:100%;height:auto;-ms-interpolation-mode:bicubic}section figcaption{font-size:0.75em;line-height:1.1;text-align:center}a{color:#ac3939;color:hsl(var(--hue), 50%, 45%);text-decoration:none}a:hover{text-decoration:underline}.draft{font-family:var(--serif);font-size:calc(4 * var(--font-size));color:#eee;opacity:0.5;text-align:center;transform:rotate(-5deg);line-height:1.0;position:absolute;top:0;height:0;left:25%;width:50%;letter-spacing:-10px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none}h1,h2,h3,h4,h5,h6{-webkit-font-feature-settings:"liga", "clig", "calt", "kern", "palt";font-feature-settings:"liga", "clig", "calt", "kern", "palt";-webkit-font-variant-ligatures:common-ligatures contextual;font-variant-ligatures:common-ligatures contextual}h1:first-char,h2:first-char,h3:first-char{font-variant-numeric:normal}section p,section li{-webkit-font-feature-settings:"liga", "clig", "calt", "onum", "kern", "palt";font-feature-settings:"liga", "clig", "calt", "onum", "kern", "palt";-webkit-font-variant-ligatures:normal;font-variant-ligatures:normal;font-variant-numeric:oldstyle-nums;hanging-punctuation:first last;text-align:justify;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto}nav,figure,td,th,abbr,acronym,code,kbd,samp,tt,var,pre{-webkit-font-feature-settings:"liga" off, "clig" off, "kern" off, "tnum" on, "lnum" on;font-feature-settings:"liga" off, "clig" off, "kern" off, "tnum" on, "lnum" on;-webkit-font-variant-ligatures:none;font-variant-ligatures:none;font-variant-numeric:lining-nums tabular-nums slashed-zero;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}.w-auto,section>.w-auto{width:auto}.select-none{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.text-left{text-align:left}.text-center{text-align:center}.text-sm{font-size:0.875em}.font-sans{font-family:var(--sans-serif)}.font-serif{font-family:var(--serif)}.font-mono{font-family:var(--monospace)}p,figure,ul,ol{margin:24px 0;margin-top:var(--line-height);margin-bottom:var(--line-height)}header>*,section>*,footer>*,main>address,.comments{margin-left:auto;margin-right:auto}figure{text-align:center}li>ul,li>ol{margin-top:0;margin-bottom:0}figure img,figure svg,figure canvas{max-width:100%}dt{font-weight:bold}pre{width:660px;width:var(--body-width);max-width:100%;line-height:1.4;overflow:auto;border-top:1px solid #ccc;border-bottom:1px solid #ccc;border-left-width:0;border-right-width:0}pre::-webkit-scrollbar{height:1em}pre::-webkit-scrollbar-thumb:horizontal{border-radius:0.5em;background:rgba(0,0,0,0.4)}pre.simple,.comments pre{overflow:auto;width:calc(var(--body-width) * 1.2);border:none;background:transparent;background-color:transparent;box-shadow:none}pre.snippet,pre.src{border-top-style:dashed;border-bottom-style:dashed}section>pre:only-child{padding-bottom:16px;border-bottom:1px solid rgba(0,0,0,0.5)}blockquote{font-style:italic}table.standard{border:1px solid rgba(0,0,0,0.5);border-collapse:collapse}table.standard th{background-color:#f8f8f8;background:linear-gradient(to top, #f8f8f8, #f8f8f8, #f0f0f0)}table.standard td{background-color:#fff}table.standard th,table.standard td{border:1px solid rgba(0,0,0,0.5)}aside,p.note,div.note>p{width:calc(--body-width - 2em);padding:1em;background:#eee;border:1px solid #ddd;box-shadow:0 8px 6px -6px rgba(0,0,0,0.4)}svg{overflow:hidden}tt,code{padding:0 2px}main>address,section>address,section>time{display:block;width:var(--body-width);max-width:100%;font-family:var(--sans-serif);text-align:right}@media (max-width: 600px){header nav{display:none}}form{margin:0}input[type="text"]{max-width:100%;border:1px solid rgba(0,0,0,0.7);background-color:#f8f8f4;color:#000;text-align:center;font-weight:bold}input[type="text"]:focus{background-color:#fffff4}input::-webkit-input-placeholder{color:#aaa}input::-moz-placeholder{color:#aaa}input[type="search"][name="q"]{box-shadow:inset 0 2px 5px 0 rgba(0,0,0,0.5);border-radius:10px;padding:5px 10px;border-width:0}.TODO{color:#bf4040;background:#e8e3e3;border:1px solid #bf4040;margin-left:0.5ex}.DONE{color:#4040bf;background:#e3e3e8;border:1px solid #4040bf}.src .comment-delimiter,.src .nxml-comment-delimiter{color:#4488ff}.src .comment,.src .nxml-comment-content{color:#006699}.src .keyword{color:#406abf;font-weight:bold}.src .builtin{color:#508b20}.src .warning{color:#cc0000}.src .function-name{color:#268bd2;font-weight:bold}.src .variable-name{color:#00008b}.src .type{color:#6c71c4}.src .constant-face{color:#d33682}.src .doc{color:#666666;background-color:#e2e6e8}.src .string{color:#888888}.src .preprocessor{color:#859900}.src .negation-char,.src .sh-escaped-newline{color:#ff0000}.src .todo{color:#ffffff;background:#dc322f}.src .note{color:#ffffff;background:#2aa198}.src .hack{color:#ffffff;background:#859900}.src .paren{color:#a0a090;font-weight:bold}.src .minor-control-construct{color:#268bd2}.src .major-control-construct{color:#bf4040}.src-cpp .constant{color:#999999}.src-emacs-lisp .paren{color:#c9c9c4}.src-sh .string,.src-sh .comment{color:inherit}.src-python .highlight-indentation{border-right:2px solid #eeeeee}.src-css .css-selector{color:#478547}.src-css .css-property{color:#406abf}.src-xml .nxml-element-prefix{color:#bf40bf}.src-xml .nxml-element-local-name{color:#406abf;font-weight:normal}.src-xml .nxml-attribute-local-name{color:#478547}.src-xml .nxml-element-colon{color:#a3adc2}.src-xml .nxml-tag-delimiter,.src-xml .nxml-tag-slash{color:#9cabc9;font-weight:bold}table.standard td.left,table.standard th.left{text-align:left}table.standard td.center,table.standard th.center{text-align:center}table.standard td.right,table.standard th.right{text-align:right}@media screen{*[class^="section-number"]{color:hsl(var(--hue), 20%, 50%)}h2 .section-number{display:inline-block;margin-left:0;padding-left:0.5em;text-align:center;width:var(--h2-margin);color:hsl(var(--hue), 50%, 80%)}h2 .section-number+span{margin-left:0}h3 .section-number{float:left;text-align:center;width:2em;margin-right:0.5em;color:hsl(var(--hue), 25%, 90%);background:hsl(var(--hue), 50%, 50%);border-radius:4px;text-shadow:0px 2px 5px rgba(0,0,0,0.8)}}@media screen and (min-width: 550px){h3 .section-number{background:url(/img/svg-blob-mini.svg) no-repeat center center;background-size:2em 2em;height:2em;margin-left:-2.5em;margin-top:-0.3em;padding-top:0.3em}}.print-endnote{display:none}@media print{@page{margin:1in}body{--font-size: 13pt;--body-width: 100vw;--serif: "Book Antiqua", "Times New Roman", serif;--sans-serif: "Helvetica", sans-serif;--monospace: "Courier", "Courier New", monospace}h2,h3{page-break-after:avoid}figure{page-break-inside:avoid}p,li{orphans:5;widows:5}section p a,section li a{text-decoration:underline}header nav,.comments{display:none}.print-endnote{display:unset}.print-endnote li{list-style-type:none;word-break:break-all}}

            
          @media print{header::before{position:absolute;left:0;top:0;content:url(http://chart.apis.google.com/chart?chs=120x120&cht=qr&chl=http%3A%2F%2Fwww-cs-students.stanford.edu%2F~amitp%2Fgame-programming%2Fgrids%2F);}}
      
        h2, h3 {
            clear: both;
        }

        img {
            /* handle smaller screens by shrinking images */
            max-width: 25vw;
        }
        
        table.centered td {
            text-align: center;
        }

        body.widthflex main {
            margin-left: auto;
            margin-right: auto;
            max-width: calc(2 * var(--body-width));
        }

        body.widthflex section > table {
            width: auto;
        }

        figure {
            border: 1px solid #aaa;
            border-left-width: 0px;
            border-right-width: 0px;
            background-color: #ddd;
            
            text-align: center;
            padding: 1em;
        }

        body.widthflex section > figure {
            max-width: none;
            width: auto;
        }

        body.widthflex section > figure.floating {
            max-width: 400px;
            float: right;
            margin: 0 2em 2em 2em;
            border-left-width: 1px;
            border-right-width: 1px;
        }

        figcaption {
            font-style: italic;
        }
    </style></head><body class="gameprog"><header><h1>Amit’s Thoughts on Grids</h1><nav><form action="https://www.google.com/search"><ul> <li><a href="https://www.redblobgames.com/">Home</a></li> <li><a href="//simblob.blogspot.com/">Blog</a></li> <li> <a href="https://pinboard.in/u:amitp/t:gamedev/">Links</a></li> <li><a href="https://twitter.com/redblobgames">Twitter</a></li> <li><a rel="me" href="http://www-cs-students.stanford.edu/~amitp/">About</a></li> <li> <li><input type="search" name="q" placeholder="Search" size="8"></li></ul><input type="hidden" name="hq" value="site:www.redblobgames.com OR site:theory.stanford.edu/~amitp/ OR site:www-cs-students.stanford.edu/~amitp/ OR site:amitp.blogspot.com OR site:simblob.blogspot.com"></form></nav></header><main><address>9 January 2006</address><section><p>Grids are commonly used in games for representing playing areas such as maps (in games like Civilization and Warcraft), playing surfaces (in games like pool, table tennis, and poker), playing fields (in games like baseball and football), boards (in games like Chess, Monopoly, and Connect Four), and abstract spaces (in games like Tetris). I’ve attempted to collect my thoughts on grids here on these pages. I avoid implementation details (such as source code) and instead focus on concepts and algorithms. I’ve mostly used grids to represent maps in strategy and simulation games. Although many of the concepts here are useful for all sorts of grids, there is a bias towards the kinds of games I am interested in.</p><p>Grids are built from a repetition of simple shapes. I’ll cover <a href="https://en.wikipedia.org/wiki/Tilings_of_regular_polygons">squares, hexagons, and triangles</a><sup class="print-endnote">[1]</sup>; vertices, edges, and faces (tiles); coordinate systems; and algorithms for working with grids. The impatient should <strong>skip ahead</strong> to <a href="#coordinates">coordinate systems</a>. I also have a <a href="https://www.redblobgames.com/grids/hexagons/">guide to hexagonal grids</a><sup class="print-endnote">[2]</sup> with many more hex-specific algorithms.</p><h3><span>Squares</span></h3><figure class="floating"><img alt="Square Grid" src="square-grid.png"><br><figcaption>Figure 1: Square Grid</figcaption></figure><p>The most common grid is a square grid. It’s simple, easy to work with, and maps nicely onto a computer screen. Square grids are the most common grids used in games, primarily because they are easy to use. Locations can use the familiar cartesian coordinates (x, y) and the axes are orthogonal. The square coordinate system is the same even if your map squares are angled on screen in an isometric or axonometric projection.</p><h3><span>Hexagons</span></h3><figure class="floating"><img alt="Hexagonal Grid" src="hexagon-grid.png"><br><figcaption>Figure 2: Hexagon Grid</figcaption></figure><p>Hexagons have been used in some board and computer games because they offer less distortion of distances than square grids. This is in part because each hexagon has more non-diagonal neighbors than a square. (Diagonals distort grid distances.) Hexagonals have a pleasing appearance and occur in nature (for example, honeycombs). In this article, I’ll use hexagons that have flat tops and pointy sides, but the math works the same if you want pointy tops and flat sides. I also have a <a href="https://www.redblobgames.com/grids/hexagons/">more comprehensive guide</a><sup class="print-endnote">[3]</sup> that covers offset coordinates, axial coordinates, cube coordinates, pointy tops, flat tops, and many more algorithms.</p><h3><span>Triangles</span></h3><figure class="floating"><img alt="Triangular Grid" src="triangle-grid.png"><br><figcaption>Figure 3: Triangle Grid</figcaption></figure><p>Triangles are common in 3d graphics but are rarely used for game maps. A big disadvantage of triangle maps, aside from unfamiliarity, is the large perimeter and small area (the opposite of a hexagon). The small area means it’s harder to place game pieces completely within a single space on the map. In 3d graphics, triangles are the only shape that is planar; squares and hexagons can be “bent”, sometimes in impossible ways. In this article I’ll use triangles pointed up and down, but the math works the same if your triangles point left and right.</p></section><section><h2 id="parts"><span>Grid Parts</span><a class="anchor" href="#parts">#</a></h2><figure class="floating"><img alt="Grid Parts" src="grid-parts.png"><br><figcaption>Figure 4a: Grid Parts</figcaption></figure><p>Grids have three types of parts: faces (tiles), edges, and vertices. Each face is a two dimensional surface enclosed by edges. Each edge is a one dimensional line segment ending at two vertices. Each vertex is a zero dimensional point. It is common for games to focus on only one of these types of parts. “Western” games like Chess and Checkers seem to focus on faces and “eastern” games like Go and Chinese Checkers seem to focus on vertices. There are some games like Roulette that assign meaning to all three types of grid parts.</p><p>Faces, edges, and vertices show up in polygonal maps as well. Algorithms that work on faces, edges, and vertices without requiring grid coordinates will work on these polygonal maps:</p><figure class="floating"><img alt="Voronoi Grid Parts" src="voronoi-grid-parts.png"><br><figcaption>Figure 4b: Grid Parts with polygons</figcaption></figure><p>Grids and polygonal maps can be converted into graph structures by turning each face into a node and each edge between faces into a graph edge between nodes. The graph structure allows the use of graph algorithms (such as shortest path) on the grid map.</p><h3><span>Uses in games</span></h3><p>Computer games can use all three types of grid parts, but faces are the most common. Buildings, land types (grass, desert, gravel, etc.), and territory ownership use faces. Territory borders and “flow” algorithms (which simulate the flow of water, people, goods, etc., between adjacent faces) can use edges. Heights (altitude, water depth) use vertices. Roads and railroads can either use faces (as in SimCity) or edges (as in Locomotion; see <a href="http://theory.stanford.edu/~amitp/game-programming/road-applet/roads.html">my Java applet demonstrating this</a><sup class="print-endnote">[4]</sup>).</p><h3><span>Counting the parts</span></h3><p>We can count how many faces, edges, and vertices are needed to form a grid. The approach is to look at adjacency and sharing. Consider a triangle grid (see Figure 4). Each triangle face has 3 edges. Thus, we expect 3 times as many edges as faces. However, each edge is shared by 2 faces, so we have 3 edges for every 2 faces. Each triangle face has 3 vertices (corners). Each vertex is shared by 6 faces. Therefore we have 3 vertices for every 6 faces, or 1 vertex for every 2 faces. These relationships will be important when designing coordinate systems. Squares have equal numbers of faces and vertices. Hexagons have more vertices than faces. Triangles have more faces than vertices. There are always more edges than faces or vertices.</p><table class="standard centered"><thead><tr><th>Shape</th><th>Faces (F)</th><th>Edges (E)</th><th>Vertices (V)</th></tr></thead><tbody><tr><th>square</th><td>1</td><td>2</td><td>1</td></tr><tr><th>hexagon</th><td>1</td><td>3</td><td>2</td></tr><tr><th>triangle</th><td>2</td><td>3</td><td>1</td></tr></tbody></table><p>I’ll call these the <strong>F,E,V counts.</strong> The F,E,V of squares is <strong>1,2,1</strong>; of hexagons, <strong>1,3,2</strong>; of triangles <strong>2,3,1</strong>. Notice that hexagon and triangle grids have similar counts, except the vertices and faces counts are reversed. That’s because hexagon grids and triangle grids are <dfn>duals</dfn>: if you place a vertex in the center of each face of a triangle grid, you will get a hexagon grid, and vice versa. Square grids are duals of themselves. If you place a vertex in the center of each square, you will produce another square grid, offset from the first. Read more about <a href="https://en.wikipedia.org/wiki/List_of_uniform_planar_tilings">duals on Wikipedia</a><sup class="print-endnote">[5]</sup>.</p></section><section><h2 id="derivation"><span>Derivation of Hexagon and Triangle Grids</span><a class="anchor" href="#derivation">#</a></h2><p>Hexagon and triangle grids can be derived from square grids. (Try changing the angle in <a href="http://nodename.com/wpEmbeds/VoronoiLattice/DelaunayLattice.swf">this Flash demo</a><sup class="print-endnote">[6]</sup>.) Since coordinate systems for squares are straightforward, the derivation will guide us in designing coordinate systems for hexagons and triangles.</p><h3><span>Squares to Hexagons</span></h3><p>There are two steps needed to turn a square grid into a hexagon grid. First, we must offset the columns (or rows). Second, we split half the square edges and bend them in the middle.</p><figure><img alt="Offsetting a square grid to make a hexagonal grid" src="square-to-hexagon-1.png">       <img alt="Another way to offset a square grid to make a hexagonal grid" src="square-to-hexagon-2.png"><br><figcaption>Figure 5: Square Grid, approaches to offsets</figcaption></figure><!-- http://bl.ocks.org/2932721 --><p>There are two simple ways to offset columns. The most common is to offset every other column (see the first grid in Figure 5). Code using this approach looks at whether it’s an odd or even column and chooses whether to offset it. A simpler approach is to offset each column by half a height more than the previous column (see the second grid in Figure 5). Code using this approach is more uniform, but the map shape is no longer rectangular, which can be inconvenient. On these pages I will focus on the latter approach; it’s easier to work with and can be also used with triangles. (In a future version of this page I may cover the other form as well.)</p><figure><img alt="Widen squares into hexagons, stage 1" src="square-to-hexagon-2.png"><img alt="Widen squares into hexagons, stage 2" src="square-to-hexagon-3.png"><img alt="Widen squares into hexagons, stage 3" src="hexagon-grid.png"><br><figcaption>Figure 6: Widening squares into hexagons</figcaption></figure><p>With either offset approach, the next step is to split the vertical edges of the squares and bend them, as shown in Figure 6. When the bend is reduced from 180 degrees to 120 degrees, you will have regular hexagons. Note that splitting the vertical edges means we’ve increased the number of edges from 4 to 6 (a net increase of 1 edge per face, since the 2 new edges are shared by 2 faces). We’ve also increased the number of vertices from 4 to 6 (but these vertices are shared, so the net increase is 1), and we’ve left the number of faces unchanged. The F,E,V counts go from 1,2,1 to 1,3,2.</p><h3><span>Squares to Triangles</span></h3><figure><img alt="Square grid" src="square-grid-small.png">     <img alt="Rhombus grid, from shearing a square grid" src="rhombus-grid-small.png"><img alt="Triangle grid, from subdividing rhombuses" src="triangle-grid-small.png"><br><figcaption>Figure 7: Shearing squares into rhombuses, then subdividing them</figcaption></figure><p>There are two steps needed to turn a square grid into a triangle grid. First, we must <a href="https://en.wikipedia.org/wiki/Shear_mapping">shear</a><sup class="print-endnote">[7]</sup> the squares. This gives us a rhombus grid (see Figure 7). To make triangles we split each rhombus face into two triangles. Splitting each face means we now have twice as many faces as before, we’ve added 1 edge for each face, and we haven’t added any vertices. The F,E,V counts go from 1,2,1 to 2,3,1.</p></section><section><h2 id="coordinates"><span>Coordinate Systems</span><a class="anchor" href="#coordinates">#</a></h2><p>There are three grid parts, and we need a way to address each of them. I’ll start with simple numeric coordinates that match the grid’s axes. <strong>The F,E,V counts tells us how many grid parts share the same coordinate.</strong> If more than one part has the same coordinate, I’ll use a capital letter to disambiguate.</p><h3><span>Square Grids</span></h3><figure><img alt="Faces of a square" src="square-grid-face-coordinates.png">     <img alt="Edges of a square" src="square-grid-edge-coordinates.png">    <img alt="Vertices of a square" src="square-grid-vertex-coordinates.png"><br><figcaption>Figure 8: Square grid coordinate systems: faces, edges, vertices</figcaption></figure><p>Square grids are fairly easy. See the first diagram in Figure 8 for the standard coordinate system for faces. The F,E,V counts are 1,2,1. That means only edges will need a letter for disambiguation. For every face we (arbitrarily) assign one vertex to share its coordinate. I’ve chosen the southwest corner of the face. Compare the face diagram to the vertex diagram to see how the coordinates are related. For each face we assign two edges to share its coordinate. I’ve chosen the south and west edges, and annotated the coordinates with the letters <code>S</code> and <code>W</code>. Compare the face diagram with the edge diagram to see how the coordinates are related. There is one face, two edges, and one vertex that share the (1, 1) grid coordinate. This matches our F,E,V counts of 1,2,1.</p><h3><span>Hexagon Grids</span></h3><figure><img alt="Faces of a hexagon" src="hexagon-grid-face-coordinates.png">     <img alt="Edges of a hexagon" src="hexagon-grid-edge-coordinates.png">    <img alt="Vertices of a hexagon" src="hexagon-grid-vertex-coordinates.png"><br><figcaption>Figure 9: Hexagon grid coordinate systems: faces, edges, vertices</figcaption></figure><p>We created the hexagon grid out of a square grid. The coordinates of a hexagon face can be the same as the coordinates of the square face that was transformed into that hexagon. Compares Figure 8 to Figure 9 and you can see how the face coordinates are related. For each face we choose three edges and two vertices to share the same coordinate. I’ve chosen the NW, N, and NE edges, and labeled them W, N, E. I’ve chosen the leftmost and rightmost vertices and labeled them L, R. Many other assignments are possible.</p><h3><span>Triangle Grids</span></h3><figure id="figure-10"><img alt="Faces of a triangle" src="triangle-grid-face-coordinates.png">     <img alt="Edges of a triangle" src="triangle-grid-edge-coordinates.png">    <img alt="Vertices of a triangle" src="triangle-grid-vertex-coordinates.png"><br><figcaption>Figure 10: Triangle grid coordinate systems: faces, edges, vertices</figcaption></figure><p>We created a triangle grid out of a square grid, and we split each sheared square (rhombus) into two triangles. This means each square face coordinate needs to be two triangle face coordinates. I chose to label them L and R, as seen in Figure 10. The edges are the same as those for squares (W and S), except we have one additional edge from the splitting of the face in two, and I’ve labeled that E. The extra triangle face does not create any additional vertices, so the vertex labeling is the same as the square grid labeling.</p><p>There’s another scheme described <a href="https://github.com/mhwombat/grid/wiki/Triangular-tiles">here</a><sup class="print-endnote">[8]</sup> that I need to study. It seems simpler than what I have here. And also see <a href="https://twitter.com/ZenoRogue/status/1081254363216138240">this scheme</a><sup class="print-endnote">[9]</sup> - elegant approach when your map is a triangle.</p></section><section><h2 id="relationships"><span>Relationships between Grid Parts</span><a class="anchor" href="#relationships">#</a></h2><p>Given each of the 3 grid parts, we can define relationships with 3 grid parts, giving us 9 relationships. There are more relationships you can define, but I’ll focus on these 9. I don’t know the standard names for these relationships, so I’ve made up some names.</p><table class="standard centered"><thead><tr><th rowspan="2">Part A (black)</th><th colspan="3">Part B (red)</th></tr><tr><th>Face</th><th>Edge</th><th>Vertex</th></tr></thead><tbody><tr><th>Face</th><td>Neighbors:<br><img alt="Neighbors of a square" src="square-rel-face-face.png"></td><td>Borders:<br><img alt="Borders of a square" src="square-rel-face-edge.png"></td><td>Corners:<br><img alt="Corners of a square" src="square-rel-face-vertex.png"></td></tr><tr><th>Edge</th><td>Joins:<br><img alt="Joins of an edge" src="square-rel-edge-face.png"></td><td>Continues:<br><img alt="Continuation of an edge" src="square-rel-edge-edge.png"></td><td>Endpoints:<br><img alt="Endpoints of an edge" src="square-rel-edge-vertex.png"></td></tr><tr><th>Vertex</th><td>Touches:<br><img alt="Vertex touching" src="square-rel-vertex-face.png"></td><td>Protrudes:<br><img alt="Vertex protrusion" src="square-rel-vertex-edge.png"></td><td>Adjacent:<br><img alt="Adjacent vertices" src="square-rel-vertex-vertex.png"></td></tr></tbody></table><p>In your game you may want to use variants of the above. For example, the <strong>neighbors</strong> and <strong>adjacent</strong> relationships could have included diagonals. The <strong>continues</strong> relationship could have included edges that weren’t colinear with the original edge. I chose the simplest relationships.</p><h3><span>Algorithms</span></h3><p>Each of these 9 relationships can be expressed in as algorithms from A to a list of Bs; I write them as <strong>A → B<sub>1</sub> B<sub>2</sub> B<sub>3</sub>…</strong> . There are 3 shapes, so that gives us 27 potential algorithms, expressed here in a simple form that you can translate into your favorite programming language. For some shapes and algorithms, there is more than one variant of <strong>A</strong>, so I will list the rules for each variant. For example, triangle faces come in <strong>L</strong> and <strong>R</strong> variants. Here are all the algorithms:</p><table class="standard"><thead><tr><th rowspan="2">Relationship</th><th colspan="3">Shape</th></tr><tr><th>Square</th><th>Hexagon</th><th>Triangle</th></tr></thead><tbody><tr><th>Neighbors:<br><img src="square-rel-face-face.png"></th><td>(u,v) → (u,v+1) (u+1,v) (u,v-1), (u-1,v)</td><td>(u,v) → (u,v+1) (u+1,v) (u+1,v-1) (u,v-1) (u-1,v) (u-1,v+1)</td><td>(u,v,L) → (u,v,R) (u,v-1,R) (u-1,v,R) <br><br> (u,v,R) → (u,v+1,L) (u+1,v,L) (u,v,L)</td></tr><tr><th>Borders:<br><img alt="" src="square-rel-face-edge.png"></th><td>(u,v) → (u,v+1,S) (u+1,v,W) (u,v,S) (u,v,W)</td><td>(u,v) → (u,v,N) (u,v,E) (u+1,v-1,W) (u,v-1,N) (u-1,v,E) (u,v,W)</td><td>(u,v,L) → (u,v,E) (u,v,S) (u,v,W) <br><br> (u,v,R) → (u,v+1,S) (u+1,v,W) (u,v,E)</td></tr><tr><th>Corners:<br><img alt="" src="square-rel-face-vertex.png"></th><td>(u,v) → (u+1,v+1) (u+1,v) (u,v) (u,v+1)</td><td>(u,v) → (u+1,v,L) (u,v,R) (u+1,v-1,L) (u-1,v,R) (u,v,L) (u-1,v+1,R)</td><td>(u,v,L) → (u,v+1) (u+1,v) (u,v) <br><br> (u,v,R) → (u+1,v+1) (u+1,v) (u,v+1)</td></tr><tr><th>Joins:<br><img alt="" src="square-rel-edge-face.png"></th><td>(u,v,W) → (u,v) (u-1,v) <br><br> (u,v,S) → (u,v) (u,v-1)</td><td>(u,v,N) → (u,v+1) (u,v) <br><br> (u,v,E) → (u+1,v) (u,v) <br><br> (u,v,W) → (u,v) (u-1,v+1)</td><td>(u,v,S) → (u,v,L) (u,v-1,R) <br><br> (u,v,E) → (u,v,R) (u,v,L) <br><br> (u,v,W) → (u,v,L) (u-1,v,R)</td></tr><tr><th>Continues:<br><img alt="" src="square-rel-edge-edge.png"></th><td>(u,v,W) → (u,v+1,W) (u,v-1,W) <br><br> (u,v,S) → (u+1,v,S) (u-1,v,S)</td><td>No edges continue straight in a hexagonal grid</td><td>(u,v,W) → (u,v+1,W) (u,v-1,W) <br><br> (u,v,E) → (u+1,v-1,E) (u-1,v+1,E) <br><br> (u,v,S) → (u+1,v,S) (u-1,v,S)</td></tr><tr><th>Endpoints:<br><img alt="" src="square-rel-edge-vertex.png"></th><td>(u,v,W) → (u,v+1) (u,v) <br><br> (u,v,S) → (u+1,v) (u,v)</td><td>(u,v,N) → (u+1,v,L) (u-1,v+1,R) <br><br> (u,v,E) → (u,v,R) (u+1,v,L) <br><br> (u,v,W) → (u-1,v+1,R) (u,v,L)</td><td>(u,v,W) → (u,v+1) (u,v) <br><br> (u,v,E) → (u+1,v) (u,v+1) <br><br> (u,v,S) → (u+1,v) (u,v)</td></tr><tr><th>Touches:<br><img alt="" src="square-rel-vertex-face.png"></th><td>(u,v) → (u,v) (u,v-1) (u-1,v-1) (u-1,v)</td><td>(u,v,L) → (u,v) (u-1,v) (u-1,v+1) <br><br> (u,v,R) → (u+1,v) (u+1,v-1) (u,v)</td><td>(u,v) → (u-1,v,R) (u,v,L) (u,v-1,R) (u,v-1,L) (u-1,v-1,R) (u-1,v,L)</td></tr><tr><th>Protrudes:<br><img alt="" src="square-rel-vertex-edge.png"></th><td>(u,v) → (u,v,W) (u,v,S) (u,v-1,W) (u-1,v,S)</td><td>(u,v,L) → (u,v,W) (u-1,v,E) (u-1,v,N) <br><br> (u,v,R) → (u+1,v-1,N) (u+1,v-1,W) (u,v,E)</td><td>(u,v) → (u,v,W) (u,v,S) (u,v-1,E) (u,v-1,W) (u-1,v,S) (u-1,v,E)</td></tr><tr><th>Adjacent:<br><img alt="" src="square-rel-vertex-vertex.png"></th><td>(u,v) → (u,v+1) (u+1,v) (u,v-1) (u-1,v)</td><td>(u,v,L) → (u-1,v+1,R) (u-1,v,R) (u-2,v+1,R) <br><br> (u,v,R) → (u+2,v-1,L) (u+1,v-1,L) (u+1,v,L)</td><td>(u,v) → (u,v+1) (u+1,v) (u+1,v-1) (u,v-1) (u-1,v) (u-1,v+1)</td></tr></tbody></table><h3><span>Relations</span></h3><p>(Feel free to skip this section.) The relationships listed above are themselves related to each other. For example, <strong>borders</strong> goes from faces to edges, and it’s the inverse of <strong>joins</strong>, which goes from edges to faces. If some edge <strong>B</strong> is in the <strong>borders</strong> list of some face <strong>A</strong>, then <strong>A</strong> will be in the <strong>joins</strong> list of edge <strong>B</strong>. These 9 relationships can be distilled down into 6 mathematical <em>relations</em>.</p><p>If you had a database, you could express the relations directly. For example, here’s the relation between faces and edges in a small 1x2 square grid:</p><table class="standard"><thead><tr><th>Face</th><th>Edge</th></tr></thead><tbody><tr><td>0,0</td><td>0,0,S</td></tr><tr><td>0,0</td><td>0,0,W</td></tr><tr><td>0,0</td><td>0,1,S</td></tr><tr><td>0,0</td><td>1,0,W</td></tr><tr><td>1,0</td><td>1,0,S</td></tr><tr><td>1,0</td><td>1,0,W</td></tr><tr><td>1,0</td><td>1,1,S</td></tr><tr><td>1,0</td><td>2,0,W</td></tr></tbody></table><p>Given a relation, you can look things up in any column. For example, with the above table, looking up <code>Face==(0,0)</code> results in 4 edges, which is what the <strong>borders</strong> relationship expresses. Looking up <code>Edge==(1,0,W)</code> results in 2 faces, which is what the <strong>joins</strong> relationship expresses. A relation is more general, and allows you to look things up in many ways; each relationship (and algorithm) is an expression of one particular way of looking things up.</p><p>Given 6 relations, there should then be 12 relationships. Why do we have only 9? It’s because the Face/Face, Edge/Edge, and Vertex/Vertex relations are <em>symmetric</em>, so looking things up the other way produces the same answer. Thus, 3 of the 12 relationships are redundant, and we are left with 9.</p><h3><span>Implementation</span></h3><p>All the algorithms are straightforward. How might you implement them? You’ll first want to choose data structures for each of the three coordinate systems. I recommend keeping it very simple and transparent. All the coordinate systems I listed have an integer <code>u</code> and an integer <code>v</code>, and some of them have an annotation like <code>L</code> or <code>W</code>. For the structure, in Ruby use a class with public attrs; in Lisp use a list; in C use a struct; in Java use a class with public fields; in Python use a simple object or dict. For the annotations, in Ruby or Lisp, use symbols (<code>'L</code> or <code>:L</code>); in C, use characters (<code>'L'</code>) or an enum type (<code>L</code>); in Java, use characters; in Python, use one-character strings.</p><p>The next step is to implement the algorithms you need. The simplest thing to do is to write functions (or methods) that take <strong>A</strong> and return a list of <strong>B</strong>. If there are multiple variants of <strong>A</strong>, use a switch/case statement to branch on the annotation. This is the simplest approach, but it is not the fastest. To make things faster, your caller might pre-allocate the list, or you might provide a callback that is inlined (for example, STL function objects in C++). In some situations you’ll want to look up many <strong>A</strong>s at once, so you might provide an algorithm that works on lists of <strong>A</strong> and produces lists of lists of <strong>B</strong>.</p><p>I generally avoid giving implementations, because they are too specific to each game, but I’ll give an example of the Triangle shape in Ruby. I chose to use a list as my basic data structure, and I use Ruby symbols (like <code>:L</code>) for annotations.</p><table class="standard"><thead><tr><th>Algorithm</th><th>Ruby Code</th></tr></thead><tbody><tr><td>(<span style="background-color:#edf">u,v</span>,<span style="background-color:#fac">L</span>) → <br>     <span style="background-color:#ffd">(u,v+1) (u+1,v) (u,v)</span><br><br> (<span style="background-color:#edf">u,v</span>,<span style="background-color:#cfa">R</span>) → <br>     <span style="background-color:#dff">(u+1,v+1) (u+1,v) (u,v+1)</span></td><td><pre>  def corners(face)
    <span style="background-color:#edf">u, v</span>, side = face
    case side
    when :<span style="background-color:#fac">L</span>
      [<span style="background-color:#ffd">[u, v+1], [u+1, v], [u, v]</span>]
    when :<span style="background-color:#cfa">R</span>
      [<span style="background-color:#dff">[u+1, v+1], [u+1, v], [u, v+1]</span>]
    end
  end</pre></td></tr></tbody></table><p>It’s that simple. Each variant becomes a case in the <code>case</code> statement.</p></section><section><h2 id="transformations"><span>Coordinate Transformations</span><a class="anchor" href="#transformations">#</a></h2><p>In both 2D and 3D graphics systems, we have to transform “world” coordinates into “screen” coordinates and back. With grids, we also have to transform “grid” coordinates into “world” coordinates and back. Transformations <em>occur on points</em>. From grid to world coordinates, we transform vertices and occasionally face centers. From world to grid coordinates, we can choose whether to find the face enclosing a point, the edge closest to a point, or the vertex closest to a point.</p><h3><span>Squares</span></h3><p>Squares are easy to work with. If one side of the square has length <code>s</code> and the square edges are aligned with the x and y axes, you can multiply your grid vertex coordinates by <code>s</code> to get the world coordinates.</p><p>Going the other way, we want to determine which vertex is closest to a point in world space. Divide the world coordinates by <code>s</code> and round the float to an int to get the closest vertex. If instead you want to determine which face encloses a point in world space, use floor instead of round.</p><h3><span>Hexagons</span></h3><figure class="floating"><img src="hex-grid-metrics-labeled.png"><br><figcaption>Figure 11: Hexagon metrics</figcaption></figure><p>Hexagons are only slightly trickier to work with than squares. Computing face centers is simple. In Figure 11, there’s an <code>i</code> vector and a <code>j</code> vector. Going from hexagonal coordinates to world coordinates is a (very simple) matrix multiply:</p><div><pre style="line-height:1.0;width:20em">⎛ x ⎞     ⎡ i.x j.x ⎤ ⎛ u ⎞
⎝ y ⎠  =  ⎣ i.y j.y ⎦ ⎝ v ⎠</pre><p>Expanded out, that’s:</p><pre style="width:20em">x = i.x * u + j.x * v
y = i.y * u + j.y * v</pre></div><p>Figure 11 shows that for flat-topped hexagons, <code>i</code> is <code>(hexagon_narrow_width, 0.5*hexagon_height)</code> and <code>j</code> is <code>(0, hexagon_height)</code>, so that give us our values for <code>i.x, i.y, j.x, j.y</code>. (Pointy-topped hexagons will be silghty different.) The resulting code is:</p><pre># Face center
x = hexagon_narrow_width * u
y = hexagon_height * (u*0.5 + v)</pre><p>Computing vertices is also fairly simple. In the rest of the article I’ve labeled hexagon vertices either L or R. These two vertices occur half a hexagon width left or right of the center of the hexagon face (see Figure 9), so all we have to do is add or subtract <code>hexagon_wide_width * 0.5</code>:</p><pre># If x,y are the face center, we can adjust to find a vertex
case side
  when :L
    x -= hexagon_wide_width * 0.5
  when :R
    x += hexagon_wide_width * 0.5
end</pre><p>When working with hexagons, treat face centers as primary, and vertices as secondary.</p><p>Going from hexagonal coordinates <code>(u, v)</code> to world coordinates <code>(x, y)</code> was a matrix multiply. To go from world coordinates back to hexagons, you can solve the equations for <code>(u, v)</code>. I’ll skip the algebra; here’s the result for flat-topped hexagons:</p><pre>u = x / hexagon_narrow_width
v = y / hexagon_height - u * 0.5</pre><p>That works if you start with <code>(x, y)</code> at a face center. If you have arbitary <code>(x, y)</code> it’s a little more work. The simplest (but not most efficient) way is to consider the computed <code>(u, v)</code> plus all neighbors and determine which one is closest to the given world coordinate. This approach works for all three grid types. If you are using this for mouse selection, this is plenty fast enough. It can be optimized further by looking more closely at the polygons.</p><h3><span>Triangles</span></h3><p>Triangles are sheared and split squares. Triangle vertices only use the shearing step, which creates rhombuses. To convert triangle <em>vertices</em> from grid coordinates to world coordinates, multiply by the axis vectors <code>i</code> and <code>j</code>:</p><pre style="line-height:1.0">⎛ x ⎞     ⎡ i.x j.x ⎤ ⎛ u ⎞
⎝ y ⎠  =  ⎣ i.y j.y ⎦ ⎝ v ⎠</pre><p>Expanded out, that’s</p><pre>x = i.x * u + j.x * v
y = i.y * u + j.y * v</pre><p>To convert triangle <em>face</em> coordinates to world coordinates involves an adjustment. For face <code>(u, v, L/R)</code> first calculate the world coordinates of the lower left vertex, <code>(u, v)</code>. Then for an <code>L</code> face, add <code>(1/2 * i, 1/3 * j)</code> to the lower left vertex location. For an <code>R</code> face, add <code>(i, 2/3 * j)</code> to the lower left vertex location. The result will be the center of the face.</p><p>To convert from world coordinates to triangle vertices, first find the lower left corner of the rhombus <code>(u, v)</code> using algebra, or by inverting the i.x,j.x,i.y,j.y matrix. The rhombus contains two triangle faces. To determine which face the point is in, look at the edge that divides the two triangles inside each rhombus (edge “E” in <a href="#figure-10">Figure 10</a>). If <code>frac(u) + frac(v) &lt; 1.0</code>, the point is on the left of the line, and is therefore in the <code>L</code> face; otherwise it is in the <code>R</code> face.</p><p>When working with triangles, treat vertices as primary, and face centers as secondary. This is the opposite of how we treat hexagons.</p></section><section><h2 id="more"><span>More</span><a class="anchor" href="#more">#</a></h2><p>Distance formulas on a square grid are well known (manhattan, euclidean, diagonal distance). Distance on a hex grid using this coordinate system uses an extension of the two-axis coordinates into a third axis, and I have the formula on <a href="https://www.redblobgames.com/grids/hexagons/#distances">my hex grid page</a><sup class="print-endnote">[10]</sup>. Distance on a triangle grid is something I explore <a href="http://simblob.blogspot.com/2007/06/distances-on-triangular-grid.html">here</a><sup class="print-endnote">[11]</sup>. <a href="http://web.archive.org/web/20140711171632/http://symbo1ics.com/blog/?p=2101">This article from symbo1ics</a><sup class="print-endnote">[12]</sup> has more math for triangle grids.</p><p>What else would you like to see me include in this document? Was anything confusing? Incomplete? Incorrect? <a href="mailto:redblobgames@gmail.com">Let me know</a>.</p><p>The diagrams on this page were produced by implementing some of the grid coordinate algorithms in <a href="http://www.ruby-lang.org/en/">Ruby</a><sup class="print-endnote">[13]</sup>, then generating <a href="https://en.wikipedia.org/wiki/Svg">SVG</a><sup class="print-endnote">[14]</sup>, then converting SVG to <a href="https://en.wikipedia.org/wiki/Png">PNG</a><sup class="print-endnote">[15]</sup> using <a href="http://www.inkscape.org/">Inkscape</a><sup class="print-endnote">[16]</sup>. For a few diagrams, I manually added annotations from within Inkscape. My Ruby code is <a href="draw_grid.rb">here</a>. You can get any of the SVG diagrams by changing <code>.png</code> in the URL to <code>.svg</code>. If you’d like to use my diagrams, please email me.</p><p>There are some things I didn’t find a place for, but might be of interest. Mathematicians have found <a href="https://en.wikipedia.org/wiki/Lattice_%28group%29#Lattices_in_two_dimensions:_detailed_discussion">five types of grids in 2D space</a><sup class="print-endnote">[17]</sup>: squares, triangles, <a href="https://en.wikipedia.org/wiki/Hexagonal_lattice">hexagons</a><sup class="print-endnote">[18]</sup>, rectangles, and parallelograms. However only squares, triangles, and hexagons are regular polygons. <a href="http://masters.donntu.edu.ua/2009/fvti/hodus/library/article4/article4.html">Spiral Honeycomb Mosaic</a><sup class="print-endnote">[19]</sup> is an interesting way to assign numbers to hexagons in a hexagonal grid. It results in bizarre properties.</p></section></main><div class="divider"></div><div class="below-divider"><p>
            Email me at
            <a class="email" rel="me" href="mailto:redblobgames@gmail.com">redblobgames@gmail.com</a>,
                or tweet to <a rel="me" href="https://twitter.com/redblobgames">@redblobgames</a>,
              
            or post a public comment:
            </p><div class="print-endnote"><h3>Endnotes</h3><ol><li>[1]: 
        https://en.wikipedia.org/wiki/Tilings_of_regular_polygons</li><li>[2]: 
        https://www.redblobgames.com/grids/hexagons/</li><li>[3]: 
        https://www.redblobgames.com/grids/hexagons/</li><li>[4]: 
        http://theory.stanford.edu/~amitp/game-programming/road-applet/roads.html</li><li>[5]: 
        https://en.wikipedia.org/wiki/List_of_uniform_planar_tilings</li><li>[6]: 
        http://nodename.com/wpEmbeds/VoronoiLattice/DelaunayLattice.swf</li><li>[7]: 
        https://en.wikipedia.org/wiki/Shear_mapping</li><li>[8]: 
        https://github.com/mhwombat/grid/wiki/Triangular-tiles</li><li>[9]: 
        https://twitter.com/ZenoRogue/status/1081254363216138240</li><li>[10]: 
        https://www.redblobgames.com/grids/hexagons/#distances</li><li>[11]: 
        http://simblob.blogspot.com/2007/06/distances-on-triangular-grid.html</li><li>[12]: 
        http://web.archive.org/web/20140711171632/http://symbo1ics.com/blog/?p=2101</li><li>[13]: 
        http://www.ruby-lang.org/en/</li><li>[14]: 
        https://en.wikipedia.org/wiki/Svg</li><li>[15]: 
        https://en.wikipedia.org/wiki/Png</li><li>[16]: 
        http://www.inkscape.org/</li><li>[17]: 
        https://en.wikipedia.org/wiki/Lattice_%28group%29#Lattices_in_two_dimensions:_detailed_discussion</li><li>[18]: 
        https://en.wikipedia.org/wiki/Hexagonal_lattice</li><li>[19]: 
        http://masters.donntu.edu.ua/2009/fvti/hodus/library/article4/article4.html</li></ol></div><div class="comments" role="complementary"><div id="disqus_thread"><button style="padding:1em;width:100%" onclick="$disqus()">Load comments</button></div><script><!--
                function disqus_config(){this.page.url="http://www-cs-students.stanford.edu/~amitp/game-programming/grids/"}
                function $disqus(){;$disqus=()=>{};let s=document.createElement('script');s.async=true;s.setAttribute('data-timestamp',+new Date());s.src="//blobs.disqus.com/embed.js";document.body.appendChild(s)}
                if(document.location.hash.match(/#comment/))$disqus();
                else if(document.location.hostname!='localhost'&&'IntersectionObserver' in window){new IntersectionObserver(e=>{if(e[0].isIntersecting)$disqus()}).observe(document.getElementById('disqus_thread'))};
              --></script><noscript><a href="//%24.disqus.com/?url=http://www-cs-students.stanford.edu/~amitp/game-programming/grids/">View the discussion thread.</a></noscript></div></div><footer><div><address>
          Copyright © 2019
                  <span class="vcard"><a rel="author home copyright" class="url fn n" href="http://www-cs-students.stanford.edu/~amitp/"><span class="given-name"> Amit </span><span class="family-name"> Patel</span></a></span></address><div>
           <!-- Created: Mon Jan  9 17:43:44 PST 2006 --><!-- hhmts start -->Last modified: 10 Jan 2019<!-- hhmts end --></div></div><!-- Start of counters --><script><!--
var sc_project=417499,sc_invisible=1,sc_security="";
(function() {
var s=document.createElement('script');
s.async=true;s.src='//statcounter.com/counter/counter_xhtml.js';
if(document.location.hostname!='localhost')document.body.appendChild(s);
})();
                //--></script><noscript><div class="statcounter"><a class="statcounter" href="//statcounter.com/"><img class="statcounter" src="//c.statcounter.com/417499/0//1/" alt=""></a></div></noscript><script>
var _gap = _gap || [];
_gap.push(['_setAccount', 'UA-79181-1']);
_gap.push(['_setDomainName', 'stanford.edu']);
_gap.push(['_setCookiePath', '/~amitp']);
_gap.push(['_setAllowLinker', true]);
_gap.push(['_gat._anonymizeIp']);
_gap.push(['_trackPageview']);
_gap.push(['_gapTrackBounceViaTime', 30]);
_gap.push(['_gapTrackBounceViaScroll', 25]);
_gap.push(['_gapTrackReads', 60, 10]);
_gap.push(['_gapTrackLinkClicks']);
if (document.location.hostname != 'localhost') (function() {
    var gap = document.createElement('script');
    gap.async = true;
    gap.type = 'text/javascript';
    gap.src = '/~amitp/gap.min.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gap, s);
})();
              </script><!-- End of counters --></footer></body></html>
